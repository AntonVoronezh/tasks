<!DOCTYPE html>
<html lang="en">
<head>
   </head>
<body>

<script>
<!--Палиндром-->
palindrome('racecar'); // true
palindrome('table'); // false
palindrome('Анна'); // true
palindrome('А роза упала на лапу Азора'); // true

function palindrome(str) {
   str = str.toLowerCase().replace(/\s/g,'');
   return str === str.split('').reverse().join('');
}

<!--fizzBuzz-->
fizzBuzz(24);

function fizzBuzz(num) {
   for (let i = 1; i <= num; i++) {
      if (i % 3 === 0 && i % 5 === 0) {
         console.log('fizzbuzz');
      }
      else if (i % 3 === 0) {
         console.log('fizz');
      }
      else if (i % 5 === 0) {
         console.log('buzz');
      }
      else {
         console.log(i);
      }
   }

}



//узнать количество гласных в строке
console.log(findVowels('hello')); // 2
console.log(findVowels('why')); // 0

function findVowels(str) {
   let count = 0;
   const vowels = ['a', 'e', 'i', 'o', 'u'];

   for (let char of str.toLowerCase()) {
      if (vowels.includes(char)) {
         count += 1;
      }
   }

   return count;

}

//анаграмма
anagram('friend', 'Finder'); //true
anagram('hello', 'bye'); //false

function buildCharObject(str) {
   const charObj = {};
   str = str.toLowerCase().replace(/[^\w]/g);
   for (let char of str) {
      charObj[char] = charObj[char] + 1 || 1;
   }

   return charObj;
}

function anagram(strA, strB) {
   const aCharObj = buildCharObject(strA);
   const bCharObj = buildCharObject(strB);

   if (Object.keys(aCharObj).length !== Object.keys(bCharObj).length) {
      return false;
   }

   for (let char in aCharObj) {
      if (aCharObj[char] !== bCharObj[char]) {
         return false;
      }
   }
   return true;
}




// Oneliner
const anagram2 = (a,b) => [...a.toLowerCase()].sort().toString() === [...b.toLowerCase()].sort().toString();


// фибоначи
function fibonacci(num) {
   const result = [0, 1];

   for(let i = 2; i <= num; i++) {

      const prevNum1 = result[i - 1];
      const prevNum2 = result[i - 2];
      result.push(prevNum1 + prevNum2);
   }

   return result[num];
}

console.log(fibonacci(7));


function fibonacciShort(num) {
   let a = 1,
           b = 1;

   for (let i = 3; i <= num; i++) {
      [a,b] = [b,a + b];
   }
   return b;
}
console.log(fibonacciShort(7));


function fibonacciRecursion(num) {
   if(num < 2) {
      return num;
   }

   return fibonacciRecursion(num - 1) + fibonacciRecursion(num - 2);
}

console.log(fibonacciRecursion(7));


// Class names

let classNames = [
   'header', 'menu', 'menu-item', 'menu-item', 'menu-item', 'footer', 'menu', 'link', 'link', 'link', 'link'
];

let classNamesCount = {};
let uinqClassNames = [];

for (let i = 0; i < classNames.length; i ++) {
   let current = classNames[i];
   if (classNamesCount[current]) {
      classNamesCount[current] += 1;
   } else {
      classNamesCount[current] = 1;
      uinqClassNames.push(current);
   }
}


let result = uinqClassNames.sort((a,b) => {
   return classNamesCount[b] - classNamesCount[a];
});

console.log(result);


//console.table(classNamesCount);
//let result = [ 'link', 'menu-item', 'menu', 'header', 'footer' ];


// про валюты

const input = [
   ['usd', 'buy', 10000],
   ['usd', 'sell', 5000],
   ['gbp', 'buy', 9000],
   ['eur', 'sell', 7000],
   ['uah', 'buy', 10000],
   ['usd', 'sell', 25000],
];


const output = {
   usd: [10000, 30000],
   gbp: [9000, 0],
   eur: [0, 7000],
   uah: [10000, 0]
}


let result = {};

input.forEach((item)=> {
   let [currency, type, amount] = item;

   if (!result[currency]) {
      result[currency] = [0,0];
   }

   result[currency][type === 'buy' ? 0 : 1] += amount;
});

console.log(result);

const result2 = input.reduce((acc, curr) => {
   acc[curr[0]] = acc[curr[0]] || [0, 0];
   acc[curr[0]][curr[1] === 'buy' ? 0 : 1] += curr[2];
   return acc;
}, {});

console.log(result2);



// про лабиринт

let maze = [
   [1, 1, 1, 0, 0, 1],
   [1, 1, 1, 1, 0, 1],
   [0, 0, 0, 0, 0, 0],
   [0, 1, 1, 1, 1, 1],
   [0, 0, 0, 0, 0, 0],
   [1, 1, 1, 1, 1, 0]
];

console.log(maze);

function checkPath(start, end) {
   maze[start.y][start.x] = 5;

   let siblings = getValidSib(start);

   if (siblings.length > 0) {
      for (let i = 0; i < siblings.length; i++) {
         const current = siblings[i];

         const isSolved = current.x === end.x && current.y === end.y;
         const notVisited = maze[current.y][current.x] !== 5;

         if (isSolved || (notVisited && checkPath(current, end))) {
            // console.log(current);
            return true;
         }
      }
   }
   return false;
}

function getValidSib(cord) {
   const { x, y } = cord;

   let cords = [];

   if (maze[y - 1] !== undefined) {
      cords.push({ x: x, y: y - 1, val: maze[y - 1][x] });
   }
   if (maze[y + 1] !== undefined) {
      cords.push({ x: x, y: y + 1, val: maze[y + 1][x] });
   }
   if (maze[y][x - 1] !== undefined) {
      cords.push({ x: x - 1, y: y, val: maze[y][x - 1] });
   }
   if (maze[y][x + 1] !== undefined) {
      cords.push({ x: x + 1, y: y, val: maze[y][x + 1] });
   }

   return cords.filter((crd) => crd.val === 0);
}

console.log(checkPath({ x: 3, y: 0 }, { x: 5, y: 5 }));
console.log(maze);


// банкомат

//REQUIREMENTS:
// 1. Always deliver the lowest number of possible notes;
// 2. It's possible to get the amount requested with available notes;
// 3. The client balance is infinite;
// 4. Amount of notes is infinite;
// 5. Available notes 100, 50, 20 10

function iWantToGet(ammountRequired) {
   const availableNotes = [100, 50, 20, 10];
   const result = [];

   if (ammountRequired > 0) {
      for (let i = 0; i < availableNotes.length; i++) {
         let note = availableNotes[i];

         while (ammountRequired - note >= 0) {
            ammountRequired -= note;
            result.push(note);
         }
      }
   } else {
      console.log("Pls enter new amount");
   }

   return result;
}

console.log(iWantToGet(0));




</script>

</body>
</html>
